---
title: "Assignment1_Data621"
author: "Mubashira Qari, Marco Castro"
date: "2025-02-09"
output:
  html_document:
    df_print: paged
---

### Load Libraries

```{r global_options, include=FALSE}
library(tidyverse)
library(ggplot2)
library(skimr)
# 
require(car)
require(DataExplorer)
require(miscTools)
require(MASS)
require(performance)
require(lmtest)
require(mice)
require(caret)
require(glmnet)
require(Metrics) 
```

## Data Exploration

In this section, we perform our exploratory analysis to understand our dataset and identify potential issues such as missing values and outliers.

### Loading Datasets

First, we load in our data

```{r}

eval_data <- read.csv("moneyball-evaluation-data.csv")
train_data <- read.csv("moneyball-training-data.csv")

head(eval, n=3)
head(train, n=3)

# convert to data.frame and drop INDEX fields
eval_df <- data.frame(eval_data) |>
  drop_columns("INDEX")
train_df <- data.frame(train_data) |>
  drop_columns("INDEX")
```
### Understanding the TARGET_WINS Field in the Moneyball Dataset:

The TARGET_WINS field represents the number of games a team won in a given baseball season. 

This is the dependent variable (target variable) in the multiple linear regression model.

We will be trying to predict TARGET_WINS based on other team performance metrics.

### Viewing Field Values:

We can see there are fields with null values

```{r}
str(eval_df)
str(train_df)
```
### Faceted Scatter Plot with Linear Regression Lines:

These scatter plots give us a sense of the relationship between the each variable and TARGET_WINS. Data points are plotted where the x-axis represents the predictor variable, and the y-axis represents the number of wins. A black trend line is fitted using linear regression is showing the general direction of the relationship.

```{r}
train_df %>%
  gather(variable, value, -TARGET_WINS) %>%
  ggplot(., aes(value, TARGET_WINS)) + 
  geom_point(fill = "#628B3A", color="#628B3A")  + 
  geom_smooth(method = "lm", se = FALSE, color = "black") + 
  facet_wrap(~variable, scales ="free", ncol = 4) +
  labs(x = element_blank(), y = "Wins")
```
_Interpretation_

The slope of the regression line in each facet is used to determine the strength of relationship between the independent variable represent on the x-axis vs the dependent variable y (TARGET_WINS). The steeper the slope, the stronger the relationship is between the two variables. The direction of the slope tells whether the relationship is positive or negative: 
- if the line is sloped to the right, it is a positive relationship meaning we can expect an increase in y as x increases
- if the line is sloped to the left, it is a negative relationship meaning we can expect an decrease in y as x increases
- if the trend line is flat, there is likely no meaningful relationship between that variable and TARGET_WINS.

If the points are closely clustered around the line, it suggests a stronger linear relationship. If the points are widely scattered, the variable may not strongly predict TARGET_WINS.

_Positive Predictors of Wins:_ TEAM_BATTING_2B, TEAM_BATTING_BB, TEAM_BATTING_H, TEAM_PITCHING_BB (unexpected).

_Negative Predictors of Wins:_ TEAM_FIELDING_E, TEAM_PITCHING_H, TEAM_PITCHING_SO.

_Weak or No Influence:_ TEAM_BATTING_3B, TEAM_BATTING_HBP, TEAM_BATTING_SO, TEAM_FIELDING_DP, TEAM_PITCHING_HR.

### Added-Variable Plots

An added variable plot (also known as a partial residual plot) is used to visualize the relationship between a predictor and the response variable, while accounting for the effects of other variables in the model. It's particularly useful in multiple regression to understand the relationship of each predictor while controlling for the others.

```{r}
# Create Added Variable Plots for the model
avPlots(lm(TARGET_WINS ~., train_df), ask = FALSE)  # ask = FALSE suppresses interactive prompts
```

_Interepretation_

### Correlation

Correlation indicates the strength and direction of a relationship between two variables. This is indicated using a scale from 1 to -1, where 1 represents a perfect positive correlation, -1 indicates a perfect negative correlation, and 0 represents no relationship. For positive correlation, as the X value increases, the Y value should increase by the valu e of our positive slope. For negative correlation, as the X value increases, the value of Y decreases.

_Considerations_
- Strong positive correlation (> 0.5)	-> keep the variable in regression.
- Strong negative correlation (< -0.5) -> Keep (inverse relationship).
- Weak correlation (~0)	-> Consider removing.

#### Correlation Between TARGET_WINS and [x]

```{r}
correlation_with_target <- cor(train_df, use = "complete.obs")["TARGET_WINS", ] %>%
  sort(decreasing = TRUE)  # Sort from highest to lowest correlation
print(correlation_with_target)

library(ggplot2)

correlation_data <- data.frame(Variable = names(correlation_with_target), Correlation = correlation_with_target)

ggplot(correlation_data, aes(x = reorder(Variable, Correlation), y = Correlation, fill = Correlation > 0)) +
  geom_bar(stat = "identity") +
  coord_flip() +  # Flip for better readability
  labs(title = "Correlation with Target Wins", x = "Variables", y = "Correlation") +
  scale_fill_manual(values = c("red", "blue")) +
  theme_minimal()

```





### Multicollinearity

One of our assumptions for regression analysis is independence of our predictors. This means that the independent variables should not be strongly correlated with one another. When two or more independent variables are correlated, this leads to a problem known as multicollinearity. The heatmap below shows the correlation between each of the variables in our dataset.

```{r correlation-heatmap}
plot_correlation(train_df, type = "all")
```
_Interpretration_

The Correlation Heatmap shows that the following variables are very highly correlated with one another
- TEAM_BATTING_HR and TEAM_PITCHING_HR have a correlation value of 0.97
- TEAM_FIELDING_E and TEAM_PITCHING_H have a correlation value of 0.67
- TEAM_FIELDING_E and TEAM_BATTING_BB have a correlation value of -0.66
- TEAM_BATTING_3B and TEAM_BATTING_HR have a correlation value of -0.64
- TEAM_FIELDING_E and TEAM_BATTING_HR have a correlation value of -0.59
- TEAM_FIELDING_E and TEAM_PITCHING_HR have a correlation value of -0.57
- TEAM_BATTING_H and TEAM_BATTING_2B have a correlation value of -0.57
- TEAM_FIELDING_E and TEAM_BATTING_3B have a correlation value of 0.51

### Summary of Datasets

The _skim_ function is helpful in identifying missing variables. It also gives us summary statistics for the mean, standard deviation, interquartiles, and even a histogram.
```{r}
skim(eval_df)
skim(train_df)
```

Missing from skim is the median which is shown below:

```{r}
train_df %>%
  summarise(across(where(is.numeric), list(median = median), na.rm = TRUE))
```





### Analysis of the training Dataset Before Fitting a Multiple Linear Regression Model:

Before fitting a multiple linear regression (MLR) model, we analyze the dataset for potential issues such as missing values, extreme outliers, multicollinearity, and variable distributions. 

Here's what we can infer from the summary statistics:

#### 1. Understanding the Target Variable (TARGET_WINS)

Range: 0 to 146 wins

Mean: ~80.79 wins

Median: 82 wins

Distribution: The min value of 0 and max of 146 suggest some potential outliers or erroneous data points, since most teams win between 50-110 games in a season.


```{r}

boxplot(train_df$TARGET_WINS, main="Distribution of Team Wins", ylab="Wins", col="lightblue")

```

_Actionable Steps:_

- Drop row with zero (0) value.

#### 2. Missing Values

Some variables have a significant number of missing values. In particular:

- TEAM_BATTING_SO (102 missing values)
- TEAM_BASERUN_SB (131 missing values)
- TEAM_BASERUN_CS (772 missing values) <- potentially unreliable
- TEAM_BATTING_HBP (2085 missing values) <- very unreliable
- TEAM_PITCHING_SO (102 missing values)
- TEAM_FIELDING_DP (286 missing values)

Additionally, four variables have values of zero (0) reported that appear suspicious. In particular:
- TEAM_BATTING_SO & TEAM_PITHCING_SO have the same rows entered as zero suggesting that data may not have been available for these entries.
- TEAM_BATTING_HR & TEAM_PITHCING_HR have the same rows entered as zero suggesting that data may not have been available for these entries.

_Actionable Steps:_

- Impute missing values (using mean/median or regression techniques).

- Consider removing TEAM_BATTING_HBP and TEAM_BASERUN_CS if they are highly incomplete and do not contribute much.

#### 3. Potential Outliers & Data Issues

Several variables have extreme max values that seem unrealistic. Specifically:

- TEAM_PITCHING_H (Max = 30,132) <- Likely an error since typical values range from 1,200 - 1,700.
- TEAM_PITCHING_SO (Max = 19,278) <- Suspiciously high (typical range: 500 - 1,500).

- TEAM_PITCHING_BB (Max = 3,645) <- Very high (typical range: 300 - 700).
- TEAM_FIELDING_E (Max = 1,898) <- Likely an error since the normal range is ~ 70-200.


_Actionable Steps:_

- Check for data entry errors.

- Remove extreme outliers if they distort model performance.

#### 4. Feature Selection Considerations:

Batting Variables: TEAM_BATTING_H, TEAM_BATTING_2B, TEAM_BATTING_3B, TEAM_BATTING_HR, TEAM_BATTING_BB are likely strong predictors of team wins. Note that TEAM_BATTING_H includes TEAM_BATTING_2B, TEAM_BATTING_3B, TEAM_BATTING_HR data.

Pitching Variables: TEAM_PITCHING_H, TEAM_PITCHING_HR, TEAM_PITCHING_BB, TEAM_PITCHING_SO will impact defensive strength.

Fielding Variables: TEAM_FIELDING_E (errors) and TEAM_FIELDING_DP (double plays) may have a weaker impact compared to batting and pitching.

_Actionable Steps:_

TEAM_PITCHING_H, TEAM_PITCHING_HR, and TEAM_PITCHING_BB may be highly correlated, which can cause multicollinearity in the regression model.

TEAM_BATTING_H, TEAM_BATTING_2B, and TEAM_BATTING_3B may also be strongly correlated since total hits include doubles and triples.

#### 5. Data Cleaning Recommendations Before Fitting the Model

Handle Missing Values

Consider dropping or imputing variables with too many missing values (e.g., TEAM_BATTING_HBP).

Impute TEAM_BASERUN_SB, TEAM_BASERUN_CS, and TEAM_FIELDING_DP appropriately.

- Remove or Adjust Extreme Outliers

Remove highly unrealistic values in pitching, fielding, and errors.

- Check for Multicollinearity

Use Variance Inflation Factor (VIF) to detect multicollinearity and drop redundant features.

- Feature Engineering

Consider derived metrics like batting average (H/AB), on-base percentage (OBP), or earned run average (ERA) instead of raw counts.

_Conclusion_

The dataset contains inconsistencies, missing values, and extreme outliers that need to be addressed before fitting an MLR model. 

Once cleaned, feature selection and multicollinearity checks will be essential to ensure a robust and interpretable model for predicting team wins.


### Analysis of the Box Plot for TARGET_WINS (Team Wins Distribution)

This box plot provides valuable insights into the distribution of team wins in the training dataset. 

Here’s what we can infer:

#### 1. Median and Spread of Wins

The thick horizontal line inside the box represents the median (~82 wins).

The box itself (Interquartile Range - IQR) shows the middle 50% of the data, which seems to range roughly from 70 to 92 wins.

#### 2. Box Plot – for Outlier Detection & Distribution Analysis:

- Low-end outliers (~0-40 wins): There are several small circles (outliers) below the lower whisker.

- High-end outliers (~110-146 wins): There are some outliers above the upper whisker, but visually fewer than the low-end.

### Consideration for Regression?

- These low-win teams might be problematic for modeling because they could represent incomplete or missing data.

- Potential data entry issues (e.g., a team with 0 wins) should be checked.

- If extreme values skew the regression, we might need transformations (log scaling)

#### 3. Data Skewness and Symmetry

The box is fairly centered, suggesting a roughly symmetric distribution.


```{r}

hist(train_df$TARGET_WINS, 
     main = "Histogram of Team Wins with Density Curve", 
     xlab = "Wins", 
     col = "lightgray", 
     border = "black", 
     breaks = 20, 
     probability = TRUE)  # Converts y-axis to density

lines(density(train_df$TARGET_WINS, na.rm = TRUE), 
      col = "red", 
      lwd = 2)  # Adds a red density curve
```

## Data Preparation

- Analyze Missing Values from Train Datasets.



```{r}

missing_values <- train_df %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Missing_Count")

print(missing_values)

```

```{r}
ggplot(missing_values, aes(y = reorder(Variable, Missing_Count), x = Missing_Count, fill = Missing_Count > 0)) +
  geom_col() +
  labs(title = "Missing Values in Training Dataset",
       x = "Number of Missing Values",
       y = "Variables") +
  scale_fill_manual(values = c("gray", "red"), labels = c("No Missing", "Has Missing")) +
  theme_minimal()
```
### Strategy for Missing Values Column wise:

There are four main options for handling missing values:

#### 1. Remove Rows with Missing Target (TARGET_WINS)

If the TARGET_WINS column has missing values, remove those rows since we can’t predict missing outcomes.

```{r}

train_df <- train_df %>% filter(!is.na(TARGET_WINS))

```

#### 2. Removing Columns with Too Many Missing Values

If a column has too many missing values (e.g., >50% missing), it may be better to remove it.

The _TEAM_BATTING_HBP_ column is mostly empty and not critical.

```{r}

train_df <- train_df[, !names(train_df) %in% "TEAM_BATTING_HBP"]

```
#### 3. Address Suspicious Values

The variables _TEAM_BATTING_SO_, _TEAM_PITCHING_SO_, _TEAM_BATTING_HR_, and _TEAM_PITCHING_HR_ included several observations with a value of zero. As the rows were the same for both variables, it appears that these may also be missing observations as the likelihood that a team's batters did not have a single strikeout nor did their pitchers pitch a single strikeout over the course of a 162 game season is highly unlikely. We will therefore treat these as missing observations and impute using the median value which is more robust to outliers then using the mean values. We will also drop the single row where the team did not win a single game, as this is also suspicious.

```{r model4-transformations}

# Convert dubious stats to NAs for pitching
# and drop unnecessary columns
train_df <- train_df |>
  mutate(
    TEAM_BATTING_SO = if_else(TEAM_BATTING_SO > 0, TEAM_BATTING_SO, NA_integer_),
    TEAM_PITCHING_SO = if_else(TEAM_PITCHING_SO > 0, TEAM_PITCHING_SO, NA_integer_),
    TEAM_BATTING_HR = if_else(TEAM_BATTING_HR > 0, TEAM_BATTING_HR, NA_integer_),
    TEAM_PITCHING_HR = if_else(TEAM_PITCHING_HR > 0, TEAM_PITCHING_HR, NA_integer_)
  ) |>
  filter(TARGET_WINS > 0) 
```



### Handling Missing Values

Next, we will address the remaining missing values. We will weight several options

#### Option 1: Removing Missing Values

- Missing Values Cause Errors in Regression Models

- lm() in R cannot handle missing values and will return an error if NAs exist in predictor variables.

- Removing missing values ensures that the model runs smoothly without interruptions.

_Pros_

- Convenience. If too many rows have missing values, R removes them automatically, reducing sample size.


_Cons_

- If missing values are not randomly distributed, removing them may bias the dataset.

- Reduced sample size 

_Conclusion_

Instead of na.omit(), imputation methods (like mean/median filling) may be better for handling missing data.

Removing rows with missing data is sometimes not the best approach, especially if a large portion of data is lost. We will therefore explore other methods.

#### Option 2: Mean

Instead of removing missing values, fill them with the mean:

```{r}

train_df_mean <- train_df
mean_val <- colMeans(train_df, na.rm = TRUE)

# Impute using Means
for(i in colnames(train_df))
    train_df[,i][is.na(train_df[,i])] <- mean_val[i]

plot_qq(train_df, sampled_rows = 1000L)

# Missing values per column
colSums(is.na(train_df_mean))

```
_Pros_

_Cons_
Not usually recommended for serious analyses because it reduces the variance and doesn't account for the uncertainty in imputations.

#### Option 3: Median

Instead of removing missing values, fill them with the median:

```{r}

library(miscTools)

train_df_median <- train_df
median_val <- colMedians(train_df, na.rm = TRUE)

# Impute using medians
for(i in colnames(train_df))
    train_df_median[,i][is.na(train_df_median[,i])] <- as.integer(median_val[i])

plot_qq(train_df_median, sampled_rows = 1000L)
# Missing values per column
colSums(is.na(train_df_median))
```

_Pros_

_Cons_

#### Option 4: Multivariate Imputation by Chained Equations (MICE)

Multivariate Imputation by Chained Equations (MICE) is a type of Multiple Imputation.

```{r mice}


train_df_mice <- mice(data=train_df, m=30, maxit=10, seed=12345, print=FALSE)
```

```{r}

train_df_clean <- train_df_mice$data
sum(is.na(train_df_clean))  # Total missing values
  
```

_Pros_

_Cons_

### Splitting the training dataset

We split the original training dataset into a training and testing dataset in order to test the strength of our model without testing the model on data that the model has already seen. The training dataset will hold 75% of our original observations, while the test dataset will hold 25%. 

```{r model4-split-data}

smp_size <- floor(0.75 * nrow(train_df_clean))
 nrow(train_df_clean)
## set the seed to make your partition reproducible
set.seed(123)
train_ind <- sample(seq_len(nrow(train_df_clean)), size = smp_size)

stp75_train_df <- train_df_clean[train_ind, ]
stp25_test_df <- train_df_clean[-train_ind, ]
```

### Outliers

The Residuals vs. Fitted and QQ Plots show a fairly linear pattern, while Scale-Location plot suggest Homoscedasticity. However, the Residuals vs Leverage plot reveals the presence of some outliers. 

```{r model4-full}
stp_model_full <- lm(TARGET_WINS ~ ., data = stp75_train_df)
summary(stp_model_full)

# check for outliers using cooks-distance plot
plot(stp_model_full, which = 4,  id.n = 8)

# get points of influence
influence <- influence.measures(stp_model_full)
influential_points <- influence$infmat
cooks_d <- influence$infmat[, "cook.d"]
max_influence_index <- which.max(cooks_d)

```
The observation with index 2135 is particularly problematic. A closer examination reveals _TEAM_PITCHING_SO_ is almost 75% higher as the next highest value (19278 vs 12758). _TEAM_PITCHING_H_ is also unusually high for this year.

```{r model4-outlier}
influential_data_point <- stp75_train_df[max_influence_index, ]
print(influential_data_point)
```
We will drop this row since it has such a high leverage on the model. 

```{r model4-drop-outlier-2135}
# remove outlier 
stp75_train_df <- stp75_train_df |>
  filter(TEAM_PITCHING_SO < 15000)

# confirm outliers
stp_model_full <- lm(TARGET_WINS ~ ., data = stp75_train_df)
plot(stp_model_full, which = 4,  id.n = 8)
```

Charting the plot shows another point (202) with high influence. This record has a TEAM_PITCHING_SO that is more than twice the next closest value. 

```{r model4-outlier2}
# get points of influence
influence <- influence.measures(stp_model_full)
influential_points <- influence$infmat
cooks_d <- influence$infmat[, "cook.d"]
max_influence_index <- which.max(cooks_d)
influential_data_point <- stp75_train_df[max_influence_index, ]
print(influential_data_point)
```
```{r model4-drop-outlier-202}
# remove outlier at row 202
stp75_train_df <- stp75_train_df[-c(202), ]

# confirm outliers
stp_model_full <- lm(TARGET_WINS ~ ., data = stp75_train_df)

plot(stp_model_full, which = 4,  id.n = 8)
```

As the Cooks Distance (Di) value is less than 0.5 for all of the remaining outliers appear, they are not significantly influential and can be left in our dataset.

## Building Three Multiple Linear Regression Models with Manual Variable Selection


### Model 1: Base Baseball Stats Model

- This model includes fundamental offensive, defensive, and pitching stats that logically contribute to wins.

#### Why were these variables selected?

TEAM_BATTING_H (Hits): More hits increase the chances of scoring.

TEAM_BATTING_HR (Home Runs): Home runs are a major contributor to runs.

TEAM_PITCHING_SO (Strikeouts): More strikeouts reduce opponent scoring.

TEAM_FIELDING_E (Errors): More errors lead to more opponent runs (negative predictor).

Why exclude some variables?

TEAM_BASERUN_SB (Stolen Bases): Limited impact on overall wins.

TEAM_PITCHING_BB (Walks Allowed): May not be as predictive when combined with strikeouts.

#### Model Summary Statistics

```{r}

base_model <- lm(TARGET_WINS ~ TEAM_BATTING_H + TEAM_BATTING_HR + TEAM_PITCHING_SO + TEAM_FIELDING_E, data = stp75_train_df)

# View model summary
summary(base_model)

```

#### Interpreting the Coefficients of the Regression Model

1- Intercept (8.05)

When all predictor variables (TEAM_BATTING_H, TEAM_BATTING_HR, TEAM_PITCHING_SO, TEAM_FIELDING_E) are zero, a team is expected to have 8.05 wins.
Significant (p = 0.04) → The intercept is meaningful in this context.

2- TEAM_BATTING_H (Hits) → 0.05 (p < 2e-16 *)

positive & highly significant
Interpretation: For every additional hit, the team is expected to win 0.052 more games.
Example: If a team gets 100 more hits in a season, they would be expected to win ~5 more games (100 × 0.05).
Conclusion: More hits lead to more wins, which is expected in baseball.

3- TEAM_BATTING_HR (Home Runs) → -0.008 (p = 0.26026 - Not Significant)
Negative (unexpected) & not significant

Interpretation: More home runs slightly decrease wins, but the effect is very small and not statistically significant.
Example: Hitting 100 more home runs would decrease wins by 008, which doesn’t make sense. We should consider removing this variable.

Possible Issues:
Multicollinearity: Home runs may be highly correlated with other batting stats (like hits or doubles), causing misleading coefficients.
Outliers/Bad Teams: Some losing teams hit a lot of home runs but still lost, skewing results.

Solution:
Check VIF (Variance Inflation Factor) for multicollinearity.
Add an interaction term (e.g., TEAM_BATTING_HR * TEAM_BATTING_BB).
Consider removing this variable if it remains insignificant.

4_ TEAM_PITCHING_SO (Strikeouts by Pitchers) → +0.0025 (p = 0.005)
Weakly positive, borderline significant

Interpretation: More strikeouts slightly increase wins, but the effect is very small tough statistically significant (p = 0.005).
Example: If a team strikes out 500 more batters in a season, they would win 0.5 more games.

Conclusion:
Strikeouts help teams win, but they are not the strongest predictor of wins.
The effect might be hidden by other defensive factors (e.g., walks, home runs allowed).

Solution:
Consider adding walks (TEAM_PITCHING_BB) or earned run average (ERA) to capture pitching effectiveness better.

5- TEAM_FIELDING_E (Errors) → -0.023 (p < 2e-16 *)
Negative & highly significant

Interpretation: For every additional error, a team is expected to lose 0.023 more games.
Example: A team with 50 more errors in a season would lose ~1 more game (50 × 0.021).
Conclusion: More errors directly hurt a team’s chances of winning, which makes sense in baseball.

#### Key Metric Interpretation:

Residual Std. Error	13.78	The average prediction error is ~13.78 wins.

Adjusted R²	0.2349	The model explains 23.5% of variance in TARGET_WINS (not very strong). 

F-Statistic	175.6 (p < 2.2e-16)	The overall model is statistically significant.

p < 2.2e-16 → The probability of getting this result by random chance is essentially 0 (very small).

#### Conclusion: 

At least one of the predictor variables in the model significantly affects TARGET_WINS.

If the p-value is very small (< 0.05), we reject the null hypothesis that "none of the independent variables explain wins."

Our model as a whole is meaningful and explains a significant amount of variation in team wins.

At least one of our predictors (TEAM_BATTING_H, TEAM_BATTING_HR, TEAM_PITCHING_SO, TEAM_FIELDING_E) is statistically significant in predicting wins.

The F-statistic of 175.6 (p < 2.2e-16) means our model is highly statistically significant. This confirms that at least one of our variables—such as home runs, hits, strikeouts, or errors—has a real impact on predicting wins.

However, we still need to check which specific variables are the most meaningful (p-values of individual coefficients) and whether we can improve the model further.

#### Implementing Improvement in the Model:

##### Step 1: Check for Multicollinearity (VIF Test)

Multicollinearity occurs when predictor variables are highly correlated, leading to unstable coefficients and inflated standard errors.

We use the Variance Inflation Factor (VIF) test. A VIF > 5 suggests multicollinearity, and VIF > 10 is a strong sign of redundancy.

##### Run VIF test in R:

```{r}

library(car)
vif(base_model)

```

##### Interpretation
Since all VIF values are below 5, there is no significant multicollinearity in the model. This means:

Each predictor contributes unique information to explaining TARGET_WINS.
Regression coefficients are stable, and we do not need to remove any variables due to multicollinearity.
The model is not distorted by highly correlated predictors.


##### Step 2: Test Interaction Term (TEAM_BATTING_HR * TEAM_BATTING_BB)

If a team hits more home runs and draws more walks, they likely score more runs.
We test if walks amplify the impact of home runs on wins.

```{r}

interaction_model <- lm(TARGET_WINS ~ TEAM_BATTING_H + TEAM_BATTING_HR + TEAM_BATTING_BB + 
                          TEAM_BATTING_HR:TEAM_BATTING_BB + 
                          TEAM_PITCHING_SO + TEAM_FIELDING_E, 
                        data = stp75_train_df)

summary(interaction_model)

```

##### Interpretation:


Model now includes an interaction term (TEAM_BATTING_HR:TEAM_BATTING_BB) to see if walks (BB) affect the impact of home runs (HR) on wins. Let’s break down the results.

The average prediction error is ±13.31 wins, slightly better than before (13.78).
The model explains 27.2% of the variance in wins (up from 23.6% in the original model).
Similar to R², meaning additional predictors added value to the model.
The model as a whole is statistically significant (at least one predictor explains wins).

More Home Runs (HR) Alone → Fewer Wins (Unexpected):
The negative coefficient (-0.1650) on TEAM_BATTING_HR suggests that hitting more home runs alone does not necessarily lead to more wins.

Walks (BB) Alone Have a Weak Impact on Wins:
The coefficient for TEAM_BATTING_BB is negative (-0.0074) and not statistically significant (p = 0.1387).
This means that walks alone do not have a strong impact on wins.

The Interaction Term (TEAM_BATTING_HR * TEAM_BATTING_BB) is Highly Significant (p = 3.39e-10)
Positive Coefficient (+0.000301)

Teams that hit home runs AND get on base with walks tend to win more games.
This confirms that home runs are more valuable when combined with walks.

##### Visualizing the Interaction Effect:
We want to see how home runs (TEAM_BATTING_HR) and walks (TEAM_BATTING_BB) impact wins (TARGET_WINS) together.

```{r}
library(ggplot2)

ggplot(stp75_train_df, aes(x = TEAM_BATTING_HR, y = TARGET_WINS, color = TEAM_BATTING_BB)) +
  geom_point(alpha = 0.7) + 
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  scale_color_gradient(low = "blue", high = "red") +
  labs(title = "Interaction Effect of Home Runs and Walks on Wins",
       x = "Home Runs",
       y = "Wins",
       color = "Walks (BB)") +
  theme_minimal()


```
Red (high walks) teams should have higher wins for the same HRs.
Blue (low walks) teams may not benefit as much from HRs.
The trendline is steeper for teams with more walks, confirming that walks amplify HR impact.

##### Adding TEAM_BATTING_2B (Doubles) to the Model:
Doubles (2B) are a strong indicator of offensive power and often correlate with scoring more runs.
If a team doesn’t hit home runs, but hits many doubles, it can still score efficiently.

```{r}
improved_model <- lm(TARGET_WINS ~ TEAM_BATTING_H + TEAM_BATTING_HR + TEAM_BATTING_BB + 
                        TEAM_BATTING_2B + TEAM_BATTING_HR:TEAM_BATTING_BB + 
                        TEAM_PITCHING_SO + TEAM_FIELDING_E, 
                      data = stp75_train_df)

summary(improved_model)

```
##### Interpretation:

The average prediction error is ±13.42 wins (slightly better than before).
The model explains 27.9% of the variance in wins (slightly better than 27.2% in the previous model).
Adjusted for number of predictors (still an improvement from before).
The model is statistically significant overall.

##### Improvement After Adding TEAM_BATTING_2B (Doubles)?
Model performance improved slightly (R² increased from 27.2% → 27.9%).
Doubles (TEAM_BATTING_2B) unexpectedly have a negative impact on wins.

Possible issue: Doubles may be highly correlated with other batting stats (e.g., hits, HRs).
Solution: We will Check multicollinearity (VIF) or add an interaction term (e.g., TEAM_BATTING_2B * TEAM_BATTING_H).
HRs alone are still negative (-0.1612), but the interaction term remains strong.
Conclusion: HRs are only useful when paired with walks.

#### Key Findings
Adding TEAM_BATTING_2B slightly improves model performance 

R² increased from 27.2% → 27.9% (small improvement).
Residual Standard Error decreased from 13.31 → 13.25 (better fit).
Unexpected negative coefficient for doubles (-0.0429, p = 3.09e-06) 

Suggests that more doubles lead to fewer wins, which is counterintuitive.
Possible reasons:
Multicollinearity with TEAM_BATTING_H (hits).
Bad teams might hit many doubles but still lose.
Interaction term (TEAM_BATTING_HR * TEAM_BATTING_BB) remains strong and positive 

Confirms that HRs are more valuable when combined with walks.
Suggests plate discipline (BBs) is crucial for power hitters.
Decision: Should we keep TEAM_BATTING_2B?

If VIF test shows high correlation with TEAM_BATTING_H, we should drop it.
If interaction terms (e.g., TEAM_BATTING_2B * TEAM_BATTING_H) make sense, we could try that instead.

#### Test Four Assumptions:

##### Linearity 
```{r check-for-Linearity-m1i}
plot(improved_model, which=1)
```


Our diagnostic plots show a fairly linear model. 
##### Normality Check:

```{r check-for-normality-m1i}

plot(improved_model, which=2)
shapiro.test(residuals(improved_model))
# Shapiro-Wilk normality test: look for high p-value
```
Our QQ plot suggests normality thought there is obvious skewing on the tails, particularly on the right.

A Shapiro Wilk's Test statistic had a value of W = 0.9971  suggesting normality.

However, the p-value (0.0033) is less than < 0.05 suggesting that residuals do not follow a normal distribution.

##### Heterocedasticity:

```{r check-for-Heterocedasticity-m1i echo: false}

plot(improved_model, which=3)
bptest(improved_model)
# Breusch-Pagan test; look for high p-value
```
Test Statistic (BP = 200.46) suggest higher evidence of heteroscedasticity. Additionally, the p-value is extremely small (much less than 0.05), suggesting higher evidence of heteroscedasticity and that we may need to transform the data to meet the Assumption of Homoscedasticity.

##### Independence:


```{r check-for-independence-m1i}

acf(residuals(improved_model))
durbinWatsonTest(improved_model)
# Durbin Watson should be close to 2
```

Our Autocorrelation Function shows that there are lags above the blue dashed line, suggesting no autocorrelation. This is confirmed through a Durbin-Watson test statistic value of 2.03 and an autocorrelation value of -0.0017. Furthermore, as our p-value (0.558) is greater than 0.05, we do not have enough evidence to reject the null hypothesis that there is no autocorrelation. In other words, the test results suggest that our model's residuals are independent and therefore do not violate the Independence Assumption.

##### Multicolinearity:

```{r}

# Check Variance Inflation Factor (VIF)
vif(improved_model)
    
```
TEAM_BATTING_H,  TEAM_BATTING_2B,  TEAM_PITCHING_SO,  TEAM_FIELDING_E are in the range of (1-5) - No significant multicollinearity (good)

TEAM_BATTING_HR, TEAM_BATTING_HR:TEAM_BATTING_BB are in the range of (> 10) shows Severe multicollinearity (highly problematic).


### Model 2: High-Impact Features Model (Based on Correlation & VIF)

We select variables based on correlation with TARGET_WINS and ensure they are not highly correlated with each other (VIF < 5).

```{r}
library(car)

# Manually selected high-impact variables
high_impact_model <- lm(TARGET_WINS ~ TEAM_BATTING_H + TEAM_BATTING_2B + TEAM_BATTING_HR +
                        TEAM_PITCHING_HR + TEAM_PITCHING_SO + TEAM_FIELDING_E, data = stp75_train_df)

# View model summary
summary(high_impact_model)

plot(high_impact_model)

# Check for multicollinearity
vif(high_impact_model)

```

#### Why these variables?

TEAM_BATTING_2B (Doubles): Important for offensive production.

TEAM_PITCHING_HR (Home Runs Allowed): Directly impacts opponent scoring (negative impact).

Removed highly correlated variables (VIF > 5).

What changed?

Better feature selection → Based on both domain knowledge and correlation analysis.

Removes redundant variables that cause multicollinearity.

### Model 3: Log-Transformed Model (Handling Skewness & Outliers)

- Some baseball statistics (e.g., Home Runs, Strikeouts) have skewed distributions. We apply log transformation to stabilize variance.

```{r}

# Apply log transformation to selected variables
train_df_log <- stp75_train_df %>%
  mutate(
    log_BATTING_H = log1p(TEAM_BATTING_H),
    log_BATTING_HR = log1p(TEAM_BATTING_HR),
    log_PITCHING_SO = log1p(TEAM_PITCHING_SO)
  )


# Fit model with transformed variables
log_model <- lm(TARGET_WINS ~ log_BATTING_H + log_BATTING_HR + log_PITCHING_SO + TEAM_FIELDING_E, data = train_df_log)

# View model summary
summary(log_model)

plot(log_model)

```
#### Why log transformation?

Fixes right-skewed distributions (e.g., extreme HR and SO values).

Helps meet the linear regression assumption of normality.

Reduces outlier influence.

What changed?

More stable regression coefficients with reduced variability.

Improves the model fit for non-linear relationships.

#### Comparision between three Models:

- Compare Adjusted R² across models:

```{r}
summary(base_model)$adj.r.squared
summary(high_impact_model)$adj.r.squared
summary(log_model)$adj.r.squared


```
- Check Mean Squared Error (MSE):

```{r}

mse_base <- mean((stp75_train_df$TARGET_WINS - predict(base_model, stp75_train_df))^2)
mse_high_impact <- mean((stp75_train_df$TARGET_WINS - predict(high_impact_model, stp75_train_df))^2)
mse_log <- mean((train_df_log$TARGET_WINS - predict(log_model, train_df_log))^2)

print(c(mse_base, mse_high_impact, mse_log))

```
- Evaluate Multicollinearity (VIF check):

```{r}

vif(high_impact_model)


```

### Model 4: Variable Selection Using Backward Selection 

For this model, we are using backward selection to arrive at the smallest number of variables with statistical significance. In this case, we begin by creating a model containing all predictors, then gradually remove the variable with the highest P-value until only the variables with statistical significance remain. 

##### Best Subset Selection
We will use Best Subset Selection to get a estimate of the optimal number of predictors in our model. This test uses Mallows’ Cp.

```{r model4-best-subset}
library(leaps)
regfit_full = regsubsets(TARGET_WINS ~ ., data = stp75_train_df, nvmax = 11)
regfit_summary = summary(regfit_full)
plot(regfit_summary$cp, xlab="Number of variables", ylab="cp")
points(which.min(regfit_summary$cp),regfit_summary$cp[which.min(regfit_summary$cp)], pch=20,col="red")

```
Based on the _Best Subset Selection_ method, we estimate that our model should have `r which.min(regfit_summary$cp)` observations.

##### Cross Validation 
  
As an alternative to _Best Subset Selection_, we used the _Cross Validation_ method to estimate the optimal number of predictors in our model. Cross Validation divides our training dataset into k - 1  number of "folds", then tests the data on the kth "fold". For our test, we used five folds (k = 5).

```{r}
set.seed(11)
folds=sample(rep(1:5,length=nrow(stp75_train_df)))

cv_errors = matrix(NA,5,10)
for(k in 1:5) {
  best_fit = regsubsets(TARGET_WINS ~ ., data=stp75_train_df[folds!=k,], nvmax=10, method="forward")
  for(i in 1:10) {
    # Extract the selected coefficients for the i-th model
    selected_coefs = coef(best_fit, id = i)
    
    # Predict manually by calculating the linear combination of the features
    # First, subset the data for the k-th fold
    test_data = stp75_train_df[folds == k, ]
    
    # Only include the predictors that were selected
    predictors = names(selected_coefs)[-1]  # Exclude the intercept term
    
    # Calculate the predictions (including the intercept)
    pred = as.matrix(test_data[, predictors]) %*% selected_coefs[predictors] + selected_coefs[1]  
    
    cv_errors[k,i]=mean((stp75_train_df$TARGET_WINS[folds==k] - pred)^2)
  }
}

rmse_cv = sqrt(apply(cv_errors,2,mean))
plot(rmse_cv, pch=5, type="b")
```
Based on the _Cross Validation_ method, we estimate that our model should have `r which.min(rmse_cv)` observations.

##### Backward Selection Method

```{r backward-selection}
summary(stp_model_full)
AIC(stp_model_full)
```


_TEAM_BATTING_HR_ has the highest p-value. We removed TEAM_BATTING_HR from our predictors and updated the model.

```{r}

back_select_model <- update(stp_model_full, . ~ . - TEAM_BATTING_HR)
summary(back_select_model)
AIC(back_select_model)
```

_TEAM_PITCHING_SO_ has the highest p-value. We removed TEAM_PITCHING_SO from our predictors and update the model.

```{r}
back_select_model <- update(back_select_model, . ~ . - TEAM_PITCHING_SO)
summary(back_select_model)
AIC(back_select_model)
```

_TEAM_BATTING_SO_ has the highest p-value. We removed TEAM_BATTING_SO from our predictors and update the model.

```{r}
back_select_model <- update(back_select_model, . ~ . - TEAM_BATTING_SO)
summary(back_select_model)
AIC(back_select_model)
```


_TEAM_BASERUN_CS_ has the highest p-value. We removed TEAM_BASERUN_CS from our predictors and update the model.

```{r}
back_select_model <- update(back_select_model, . ~ . - TEAM_BASERUN_CS)
summary(back_select_model)
AIC(back_select_model)
```

_TEAM_PITCHING_BB_ has the highest p-value. We removed TEAM_PITCHING_BB from our predictors and update the model.

```{r}
back_select_model <- update(back_select_model, . ~ . - TEAM_PITCHING_BB)
summary(back_select_model)
AIC(back_select_model)
```

Backward selection using P-values arrives at a model with six variables with high statistical significance  ((p-value < 0.001) and three with moderate (p-value ~= 0.1) statistical significance. Arriving at 11 predictors is consistent with our Best Subset Selection test.

```{r model-4-diagnose}
vif(back_select_model)
plot(back_select_model)
```


### 4B: Alternate Model Selection

Another approach to model selection involves a combination of step-wise selection and contextual selection. In this example, we can first drop _TEAM_BATTING_2B_ (2 base hits), _TEAM_BATTING_3B_ (3 base hits), _TEAM_BATTING_HR_ (home runs) before conducting our stepwise selection, as data for these columns is represented in the _TEAM_BATTING_H_ (total hits) column, thus signaling the existence of dependence between hit count variables and total hits. It is not totally clear if _TEAM_PITCHING_HR_ is also included in _TEAM_PITCHING_H_ from the supporting document but we will remove it in the event that a similar relationship exists. __Alternatively__, we could have created a new column (TEAM_BATTING_1B) by subtracting the sum of 2 base hits, 3 base hits, and homeruns from total hits, but this alternatively solution would have a) added complexity into our model and b) added uncertainty due to possible missing values in the home runs columns. 


```{r model4-drop-hits-cols}
stp75s_train_df <- stp75_train_df |> 
    drop_columns(c("TEAM_BATTING_2B", "TEAM_BATTING_3B", "TEAM_BATTING_HR", "TEAM_PITCHING_HR"))

stp25s_test_df <- stp25_test_df |> 
    drop_columns(c("TEAM_BATTING_2B", "TEAM_BATTING_3B", "TEAM_BATTING_HR", "TEAM_PITCHING_HR"))

stp_model_sm <- lm(TARGET_WINS ~ ., data = stp75s_train_df)

# Backward step-wise regression
stpb_model_sm <- step(stp_model_sm, direction = "backward")
```

Performing an automated step-wise backward selection gives us 8 viable predictors. Examining the VIF shows that eight parameters are not strongly correlated with our dependent variable.

```{r}
vif(stpb_model_sm)
summary(stpb_model_sm)
AIC(stpb_model_sm)
plot(stpb_model_sm)
```

Looking at the p-values and t-values for the remaining 7 predictors show that there is one variables without statistical significance, TEAM_PITCHING_H. As this predictor has a high p-value (0.12) and a low t-value (-1.54), we should consider removing it.


```{r}
stpb_model_xs <- update(stpb_model_sm, . ~ . - TEAM_PITCHING_H)
summary(stpb_model_xs)
AIC(stpb_model_xs)
plot(stpb_model_xs)
```

Removing the TEAM_PITCHING_H slightly increases our AIC from 13623.39 to 13623.78 and slightly decreases the Adjusted R-squared from 0.2864 to 0.2858, but overall the models are somewhat similar the auto-generated step-wise selected model.


#### Variant Comparison

The function _compare_performance_ allows comparison of various metrics across diffrent models including R2 and R2 (adj.). It also weights AIC and BIC values to help rank the performance of our models. Based on the result of this test, it appears that our original backward-selected model performed best.

```{r model4-comparison-1}
compare_performance(back_select_model, stpb_model_sm, stpb_model_xs, rank = TRUE)
```
#### Model Diagnostics

In this section, we will test if our original backward-selected model meets the four assumptions for linearity.

##### Linearity

```{r check-for-linearity-m4}
plot(back_select_model, which=1)
```

Our diagnostic plots show a fairly linear model.

##### Normality

```{r check-for-normality-m4}

plot(back_select_model, which=2)
shapiro.test(residuals(back_select_model))
# Shapiro-Wilk normality test: look for high p-value
```
Our QQ plot suggests normality thought there is obvious skewing on the tails, particularly on the right.

A Shapiro Wilk's Test statistic had a value of 0.9967 is close to 1 suggesting normality. However, the p-value (0.0010) is less than < 0.05 suggests that residuals may not follow a normal distribution.

##### Heteroscedasticity:

```{r check-for-homoscedasticity-m4 echo: false}

plot(back_select_model, which=3)
plot(back_select_model, which=4)
bptest(back_select_model)
# Breusch-Pagan test; look for high p-value
```
Our Scale-Location plot shows that points appear somewhat evenly distributed above and below the trend line. While there is no obvious fan/wedge pattern, there is clustering in the center suggesting underfitting, high leverage outliers or that additional transformation may be needed. As our Cook's Distance plot has no values with a greater than 1, we can rule our the effects of high leverage points.

The Breusch-Page test statistic BP (210.37) and the small p-value (2.2e-16) suggest evidence of heteroscedasticity. Though the values are different that we may need to transform the data to meet the Assumption of Homoscedasticity.


##### Independence:

```{r check-for-independence-m4}

acf(residuals(back_select_model))
durbinWatsonTest(back_select_model)
# Durbin Watson should be close to 2
```

Our Autocorrelation Function shows that there are lags above the blue dashed line, suggesting no autocorrelation. This is confirmed through a Durbin-Watson test statistic value of 2.03 and an autocorrelation value of -0.0017. Furthermore, as our p-value (0.558) is greater than 0.05, we do not have enough evidence to reject the null hypothesis that there is no autocorrelation. In other words, the test results suggest that our model's residuals are independent and therefore do not violate the Independence Assumption.

_Conclusion_
The backward selected model violates the Homoscedasticity Assumption and has mixed results for our Normality Assumption. We should therefore test applying transformations to our model.

### 4C: Model with Transformed Data

So far, our diagnostic plots show that our model is somewhat linear, independent, heteroschedastic, but our residuals vs leverage indicates the presence of outliers. We will attempt to use transformations to improve our model.

#### 4Ci: Box-Cox Transformation on Dependent Variable

In this section, we apply a Box-Cox Transformation

```{r model4-boxcox}

stpbc_model <- boxcox(back_select_model, lambda = seq(-3,3))
plot(stpbc_model)
best_lambda <- stpbc_model$x[which(stpbc_model$y==max(stpbc_model$y))]
 
stp_model_inv <- lm((TARGET_WINS)^best_lambda ~ TEAM_BATTING_H + TEAM_BATTING_2B + TEAM_BATTING_3B + TEAM_BATTING_SO + TEAM_BASERUN_SB + TEAM_PITCHING_HR + TEAM_PITCHING_BB + TEAM_PITCHING_SO + TEAM_FIELDING_E + TEAM_FIELDING_DP, data = stp75_train_df)

summary(stp_model_inv)
```
Looking at the summary of our new Box-Cox transformed model shows three variables are not statistically significant. We should therefore remove them one at a time.

```{r}

stp_model_inv <- update(stp_model_inv, . ~ . - TEAM_BATTING_SO)
summary(stp_model_inv)
AIC(back_select_model)

stp_model_inv <- update(stp_model_inv, . ~ . - TEAM_PITCHING_BB)
summary(stp_model_inv)
AIC(back_select_model)

stp_model_inv <- update(stp_model_inv, . ~ . - TEAM_PITCHING_SO)
summary(stp_model_inv)
AIC(back_select_model)
```
##### Testing Our Assumptions
###### Linearity

```{r check-for-multicolinearity-m4bc}
plot(stp_model_inv, which=1)
```

Our Residuals vs. Fitted plot suggest a fairly linear model.

###### Normality

```{r check-for-normality-m4bc}

plot(stp_model_inv, which = 2)

shapiro.test(residuals(stp_model_inv))
# Shapiro-Wilk normality test: look for high p-value

```
Our QQ plot suggests normality thought there is obvious skewing on the tails, particularly on the right.

A Shapiro Wilk's Test statistic had a value of 0.996, also suggesting normality. However, since the p-value (7.132e-05) is less than < 0.05 we may still be violating our normality assumption.

###### Heteroscedasticity

```{r check-for-homoscedasticity-m4bc echo: false}

plot(stp_model_inv, which = 3)
plot(stp_model_inv, which = 4)

bptest(stp_model_inv)
# Breusch-Pagan test; look for high p-value
```
Our Scale-Location plot shows that points appear somewhat evenly distributed above and below the trend line. While there is no obvious fan/wedge pattern, there is clustering in the center suggesting underfitting, high leverage outliers or that additional transformation may be needed. As our Cook's Distance plot has no values with a greater than 1, we can rule our the effects of high leverage points.

The Breusch-Page test statistic BP (176.76) and the small p-value (2.2e-16) suggest evidence of heteroscedasticity. Though the values are different that we may need to transform the data to meet the Assumption of Homoscedasticity.

###### Independence

```{r check-for-independence-m4bc}

acf(residuals(stp_model_inv))
durbinWatsonTest(stp_model_inv)
# Durbin Watson should be close to 2
```

Our Autocorrelation Function shows that there are lags above the blue dashed line, suggesting no autocorrelation. This is confirmed through a Durbin-Watson test statistic value of 2.03 and an autocorrelation value of -0.021. Furthermore, as our p-value (0.416) is greater than 0.05, we do not have enough evidence to reject the null hypothesis that there is no autocorrelation. In other words, the test results suggest that our model's residuals are independent and therefore do not violate the Independence Assumption.

_Conclusion_
Applying a Box-Cox transformation to our model appears does not seem to have improved the results of our backward selected model. This model continues to violate the Homoscedasticity Assumption and has mixed results for our Normality Assumption.

#### 4Cii: Log Transformation on the Dependent Variable (Y)

```{r model4_logy_transform}

stp_logy_model <- lm(log(TARGET_WINS + 1) ~., data = stp75_train_df)

# Backward step-wise regression
stpb_logy_model <- step(stp_logy_model, direction = "backward")

```

##### Testing Our Assumptions
###### Linearity

```{r check-for-multicolinearity-m4logy}
plot(stp_logy_model, which=1)
```

Our Residuals vs. Fitted plot suggests a somewhat linear model but there is visible bowing in the trend line.

###### Normality

```{r check-for-normality-m4logy}

plot(stp_logy_model, which = 2)

shapiro.test(residuals(stp_logy_model))
# Shapiro-Wilk normality test: look for high p-value

```
Our QQ plot suggests normality thought there is obvious skewing on the tails, particularly on the left.

A Shapiro Wilk's Test statistic had a value of 0.980, also suggesting normality. However, since the p-value (1.416e-14) is less than < 0.05 we may still be violating our normality assumption.

###### Heteroscedasticity

```{r check-for-homoscedasticity-m4logy echo: false}

plot(stp_logy_model, which = 3)
plot(stp_logy_model, which = 4)

bptest(stp_logy_model)
# Breusch-Pagan test; look for high p-value
```
Our Scale-Location plot shows clear bowing in the trend line, suggesting that the variance of the residuals is not constant and therefore heteroschedastic. While there is no obvious fan/wedge pattern, there is clustering in the center suggesting underfitting, high leverage outliers or that additional transformation may be needed. As our Cook's Distance plot has no values with a greater than 1, we can rule our the effects of high leverage points. However, it should be pointed the leverage points appear to be more influential than in our backwards selected model or our Box-Cox transformed model.

The Breusch-Page test statistic BP (383.07) indicates a substantial relationship between the residual variance and the predictors and the small p-value (2.2e-16) suggest evidence of heteroscedasticity. Though the values are different that we may need to transform the data to meet the Assumption of Homoscedasticity.

###### Independence

```{r check-for-independence-m4logy}

acf(residuals(stp_logy_model))
durbinWatsonTest(stp_logy_model)
# Durbin Watson should be close to 2
```

Our Autocorrelation Function shows that there are lags above the blue dashed line, suggesting no autocorrelation. This is confirmed through a Durbin-Watson test statistic value of 2.00 and an autocorrelation value of -0.0041. Furthermore, as our p-value (0.96) is greater than 0.05, we do not have enough evidence to reject the null hypothesis that there is no autocorrelation. In other words, the test results suggest that our model's residuals are independent and therefore do not violate the Independence Assumption.

_Conclusion_
Applying a log transformation the dependent variable in our model appears to inferior to the backward selected model and the Box-Cox transformed model. We should therefore avoid using this model.

#### 4Ciii: Log Transformation on Independent Variables (X)

Some of our predictors (TEAM_PITCHING_SO, TEAM_PITCHING_BB, & TEAM_PITCHING_H) showed the presence of outliers. We will transform these variables with a log transformation.

```{r model4_log_transform}

stplg75_train_df <- stp75_train_df %>%
  mutate(
    TEAM_PITCHING_SO = log(TEAM_PITCHING_SO),
    TEAM_PITCHING_BB = log(TEAM_PITCHING_BB),
    TEAM_PITCHING_H = log(TEAM_PITCHING_H),
  )

stplg25_test_df <- stp25_test_df %>%
  mutate(
    TEAM_PITCHING_SO = log1p(TEAM_PITCHING_SO),
    TEAM_PITCHING_BB = log1p(TEAM_PITCHING_BB),
    TEAM_PITCHING_H = log1p(TEAM_PITCHING_H),
  )

stplg75_train_df %>%
  gather(variable, value, -TARGET_WINS) %>%
  ggplot(., aes(value, TARGET_WINS)) + 
  geom_point(fill = "#628B3A", color="#628B3A")  + 
  geom_smooth(method = "lm", se = FALSE, color = "black") + 
  facet_wrap(~variable, scales ="free", ncol = 4) +
  labs(x = element_blank(), y = "Wins")

```
Our scatter plots show some improvement in our outliers.


##### Backwards Selection

We will use backward step-wise selection to build our model.

```{r model4lg-backward-selection}

stp_logx_model_full <- lm(TARGET_WINS ~ ., data = stplg75_train_df)

# Backward step-wise regression
stp_logx_model <- step(stp_logx_model_full, direction = "backward")
```
Looking at the summary for this model shows that all predictors have high statistic significance.

```{r}
summary(stp_logx_model)
```

The Residuals vs. Fitted and QQ Plots show a fairly linear pattern, while Scale-Location plot suggest Homoscedasticity. The Residuals vs Leverage plot reveals that our outliers have less leverage than in the pre- log transformed model. 

```{r model-4-diagnostic-ph plots}
plot(stp_logx_model)

stplg75_train_df <- stplg75_train_df |>
  mutate(
    n = row_number()
  )
```

##### Multicolinearity 

A VIF Test shows several variables that are highly correlated, including TEAM_PITCHING_H, TEAM_BATTING_BB, TEAM_PITCHING_SO, TEAM_PITCHING_BB, TEAM_FIELDING_E & TEAM_BATTING_H. We may choose to leave these out. 

```{r model4lg-vif}
vif(stp_logx_model)
```

##### Testing Our Assumptions

###### Linearity

```{r check-for-multicolinearity-m4logx}
plot(stp_logx_model, which=1)
```

Our Residuals vs. Fitted plot suggest a fairly linear model.

###### Normality

```{r check-for-normality-m4logx}

plot(stp_logx_model, which = 2)

# Shapiro-Wilk normality test: look for high p-value
shapiro.test(residuals(stp_logx_model))

```
Our QQ plot suggests normality thought there is some skewing on the tails, particularly on the right. The skewing appears to be less pitched than in our backward-selected model or Box-Cox Transformed model.

A Shapiro Wilk's Test statistic had a value of 0.9943, also suggesting normality. However, since the p-value (4.273e-06) is less than < 0.05 we may still be violating our normality assumption.

###### Heteroscedasticity

```{r check-for-homoscedasticity-m4logx echo: false}

plot(stp_logx_model, which = 3)
plot(stp_logx_model, which = 4)

bptest(stp_logx_model)
# Breusch-Pagan test; look for high p-value
```
Our Scale-Location plot shows that points appear somewhat evenly distributed above and below the trend line but there is clear bowing in the trend line, suggesting that the variance of the residuals is not constant and therefore heteroschedastic. While there is no obvious fan/wedge pattern, there is clustering in the center suggesting underfitting, high leverage outliers or that additional transformation may be needed. As our Cook's Distance plot has no values with a greater than 1, we can rule our the effects of high leverage points.

The Breusch-Page test statistic BP (302.21) and the small p-value (2.2e-16) suggest evidence of heteroscedasticity. Though the values are different that we may need to transform the data to meet the Assumption of Homoscedasticity.

###### Independence

```{r check-for-independence-m4logx}

acf(residuals(stp_logx_model))
durbinWatsonTest(stp_logx_model)
# Durbin Watson should be close to 2
```

Our Autocorrelation Function shows that there are lags above the blue dashed line, suggesting no autocorrelation. This is confirmed through a Durbin-Watson test statistic value of 2.011 and an autocorrelation value of -0.008. Furthermore, as our p-value (0.822) is greater than 0.05, we do not have enough evidence to reject the null hypothesis that there is no autocorrelation. In other words, the test results suggest that our model's residuals are independent and therefore do not violate the Independence Assumption.


### Model 5: Lasso Regression 

The Least Absolute Shrinkage and Selection Operator (LASSO) selection method uses a shrinkage approach to determining the optimal predictors by attempting to find a balance between simplicity and accuracy.It applies a penalty to the standard linear regression model to encourage the coefficients of features with weak influence to equal zero to prevent overfitting.

```{r}

x = model.matrix(TARGET_WINS ~ ., data = stplg75_train_df)
y = stplg75_train_df$TARGET_WINS

fit_lasso = glmnet(x, y, alpha=1)
plot(fit_lasso, xvar="lambda", label=TRUE)
cv_lasso = cv.glmnet(x,y,alpha=1)
#plot(cv.lasso)
coef(cv_lasso)
```

Performing LASSO on our training subset -- 75% of full training set with log transformation applied --  gives us 7 predictors:
- TEAM_BATTING_H 
- TEAM_BATTING_3B 
- TEAM_BATTING_BB 
- TEAM_BASERUN_SB 
- TEAM_PITCHING_HR 
- TEAM_FIELDING_E 
- TEAM_FIELDING_DP
 

```{r lasso-summary}
lasso_model <- lm(TARGET_WINS ~ TEAM_BATTING_H + TEAM_BATTING_3B + TEAM_BATTING_BB + TEAM_BASERUN_SB + TEAM_PITCHING_HR + TEAM_FIELDING_E + TEAM_FIELDING_DP, data = stplg75_train_df)

summary(lasso_model)
vif(lasso_model)
```

Our VIF test shows no strong correlation between predictors. 

##### Testing Our Assumptions

###### Linearity

```{r check-for-multicolinearity-lasso}
plot(lasso_model, which=1)
```

Our Residuals vs. Fitted plot suggest a fairly linear model.

###### Normality

```{r check-for-normality-lasso}

plot(lasso_model, which = 2)

# Shapiro-Wilk normality test: look for high p-value
shapiro.test(residuals(lasso_model))

```
Our QQ plot suggests normality thought there is some skewing on the tails, particularly on the right. The skewing appears to be less pitched than in our backward-selected model or Box-Cox Transformed model.

A Shapiro Wilk's Test statistic had a value of 0.9964, also suggesting normality. However, since the p-value (0.0005) is less than < 0.05 we may still be violating our normality assumption.

###### Heteroscedasticity

```{r check-for-homoscedasticity-lasso echo: false}

plot(lasso_model, which = 3)
plot(lasso_model, which = 4)

bptest(lasso_model)
# Breusch-Pagan test; look for high p-value
```
Our Scale-Location plot shows that points appear somewhat evenly distributed above and below the trend line but there is slight bowing in the trend line, suggesting that the variance of the residuals is not constant and therefore heteroschedastic. While there is no obvious fan/wedge pattern, there is clustering in the center suggesting underfitting, high leverage outliers or that additional transformation may be needed. As our Cook's Distance plot has no values with a greater than 1, we can rule our the effects of high leverage points.

The Breusch-Page test statistic BP (209.89) and the small p-value (2.2e-16) suggest evidence of heteroscedasticity. Though the values are different that we may need to transform the data to meet the Assumption of Homoscedasticity.

###### Independence

```{r check-for-independence-lasso}

acf(residuals(lasso_model))
durbinWatsonTest(lasso_model)
# Durbin Watson should be close to 2
```

Our Autocorrelation Function shows that there are lags above the blue dashed line, suggesting no autocorrelation. This is confirmed through a Durbin-Watson test statistic value of 2.03 and an autocorrelation value of -0.0177. Furthermore, as our p-value (0.504) is greater than 0.05, we do not have enough evidence to reject the null hypothesis that there is no autocorrelation. In other words, the test results suggest that our model's residuals are independent and therefore do not violate the Independence Assumption.


### Comparing All Models

Here we are comparing the all models using our training subset (75% of observations).

```{r lasso-compare-1}

#stp_model_inv - is throwing errors due to difference in scales
compare_performance(base_model, high_impact_model, log_model, back_select_model, stp_model_sm, stp_logy_model, stp_logx_model, lasso_model, rank = TRUE)

```

The "compare_performance" function compares various test results including Adjusted R-Squared, AIC, and BIC. Based on these results, "compare_performance" suggests that our Log Transformed Dependent variable (stp_logy_model_) performed the best. However, this model had the most obvious violations of regression assumptions. Thus we will discard it moving forward. Re-running "compare_performance" without this model shows that 

* Note that we were unable to compare the performance as the scales differ our Step-wise model with transformed independent variables (stp_logx_model)  performs best on the tests above.

```{r lasso-compare-2}

#stp_model_inv - is throwing errors due to difference in scales
compare_performance(base_model, high_impact_model, log_model, back_select_model, stp_model_sm, stp_logx_model, lasso_model)

```



### Conclusion:


If interpretability is most important → Use base Stats Model.

If statistical optimization is preferred → Use High-Impact Model.

If non-linearity is a concern → Use Log-Transformed Model.

If statistical significance is most important → Log-Transformed Step-wise Model 

## Model Selection

#### Testing the model

In this section, we will use the test dataframe to test the accuracy of our model's predictions

```{r model4lg-test}

# Do we need to clean eval dataset first?

# Stats Model predictions
predictedWins = predict(base_model, stp25_test_df)
stp25_test_df["PREDICTED_WINS"] = predictedWins

# Improved Model predictions
predictedWins = predict(improved_model, stp25_test_df)
stp25_test_df["PREDICTED_WINS_IMP"] = predictedWins

# High-Impact Model
predictedWins = predict(high_impact_model, stp25_test_df)
stp25_test_df["PREDICTED_WINS_HIM"] = predictedWins

# Log-Transformed Model
predictedWins = predict(log_model, train_df_log)
train_df_log["PREDICTED_WINS_LOG"] = predictedWins

# Log-Transformed Step-wise Model
predictedWins = predict(stp_logx_model, stplg25_test_df)
stplg25_test_df["PREDICTED_WINS_STP"] = predictedWins

# BoxCox-Transformed Step-wise Model
### TODO: Backward Tranform
#predictedWins = predict(stp_mode_inv, train_df_log)
#train_df_log["PREDICTED_WINS_INV"] = predictedWins

```

```{r MAE test}
# Create a df to store our results
evaluation_metrics <- data.frame(
  model_name = character(0), 
  MAE = numeric(0),     
  RMSE = numeric(0),    
  RSquared = numeric(0)      
)
  
eval_predictions <- function(model, predict_col, target_col, model_name) {
  
  pred = lm(predict_col ~ target_col)
  plot(predict_col, target_col, xlab="Actual Wins", ylab="Predicted Wins")
  abline(pred)
  
  plot(model$residuals)
  
  model_metrics = data.frame(
    model_name = model_name,
    MAE = mae(target_col, predict_col),
    RMSE = rmse(target_col, predict_col),
    RSquared = (cor(target_col, predict_col)^2 )
  )
  
  evaluation_metrics <<- rbind(evaluation_metrics, model_metrics)
}

# Evaluate Stats Model predictions
eval_predictions(base_model, stp25_test_df$PREDICTED_WINS, stp25_test_df$TARGET_WINS, "Stats")

```

```{r}
# Improved Model
eval_predictions(improved_model, stp25_test_df$PREDICTED_WINS_IMP, stp25_test_df$TARGET_WINS, "Improved")
```


```{r}
# Evaluate High-Impact Model
eval_predictions(high_impact_model, stp25_test_df$PREDICTED_WINS_HIM, stp25_test_df$TARGET_WINS, "High-Impact")
```


```{r}
# Evaluate Log-Transformed Model
eval_predictions(log_model, train_df_log$PREDICTED_WINS_LOG, train_df_log$TARGET_WINS, "Log-Tranformed")
```

```{r}

# Evaluate Log-Transformed Step-wise Model
eval_predictions(stp_logx_model, stplg25_test_df$PREDICTED_WINS_STP, stplg25_test_df$TARGET_WINS, "LT Step-wise")
```

```{r}
# TODO: backward transform
# Evaluate Box-Cox Transformed Step-wise Model
#eval_predictions(stp_model_inv, train_df_log$PREDICTED_WINS_INV, train_df_log$TARGET_WINS, "Box-Cox")
```

To evaluate the accuracy of each our model's predictions, we will compare:
- the Mean Absolute Error (MAE)
- the Root Mean Squared Error (RMSE)
- the R-squared (R²)

```{r}
print(evaluation_metrics)
```
A quick examination of these shows the Log-Transformed Step-wise Model has the lowest MAE and RMSE as well as the highest R-squared, suggesting that this model is somewhat more accurate than the other four evaluated. For confirmation we will perform a 5-fold cross-validation below:

```{r model4lg-cross-validation}
library(caret)

train_control <- trainControl(method = "cv", number = 5)  # 10-fold cross-validation

model_cv <- train(TARGET_WINS ~ TEAM_BATTING_H + TEAM_BATTING_2B + 
    TEAM_BATTING_3B + TEAM_BATTING_HR + TEAM_BATTING_BB + TEAM_BATTING_SO + 
    TEAM_BASERUN_SB + TEAM_PITCHING_H + TEAM_PITCHING_BB + TEAM_PITCHING_SO + 
    TEAM_FIELDING_E + TEAM_FIELDING_DP, data = stplg75_train_df, method = "lm", trControl = train_control)

print(model_cv)

summary(stp_logx_model)
```

MAE and RMSE is even lower when using cross-validation. Although our R-squared value decreased from 0.3183 to 0.3034024, this value is still higher than the model with second highest R-squared value of 0.2368 for the Log-Tranformed model.

### Conclusion
Our previous test suggest that the Log-Transformed Step-wise Model appears to be the most accurate at predicting wins over a team's season. However, with 12 predictors, this model is fairly complex. Given the audience for our report and the need to clearly describe our model to the coach, we should select a simpler model that is still statistically significant and fairly accurate. Therefore, we will select our Improved model.

### Final Analysis

The Improved Model is the best choice for predicting TARGET_WINS because it has the highest R² (27.89%), the lowest residual standard error (13.25), and avoids severe multicollinearity issues. 

Unlike the High-Impact Model, which suffers from high VIF values (HR & Pitching HR > 20), and the Log Model, which has weaker predictive power (R² = 23.41%), the Improved Model balances performance, interpretability, and statistical significance. 

Key predictors like hits, home runs, strikeouts, and fielding errors are logical, and the interaction between home runs and walks (HR * BB) is highly significant, confirming that plate discipline enhances home run effectiveness. 

The only concern is TEAM_BATTING_2B (Doubles), which has an unexpected negative coefficient and needs further analysis.

### Assumptions of Multiple Linear Regression:

Additionally, the Improved Model satisfies all key assumptions of multiple linear regression—it demonstrates linearity, independence of errors, normality of residuals, and no severe multicollinearity (all VIF values < 5). 

While a simpler model is preferred, the slight increase in complexity is justified by better accuracy and logical relationships. 


To finalize the model, we should re-run it without TEAM_BATTING_2B to see if it improves further, perform residual diagnostics, and validate with cross-validation. Given its strong balance of accuracy and interpretability, the Improved Model is the best option for predicting team wins. 


Making Predictions Using the Evaluation Dataset:

### Data Preparation:

- Analyze Missing Values from Train Datasets.


```{r}

missing_values <- eval_df %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Missing_Count")

print(missing_values)


```

### Removing Mostly NA and INDEX Column:

```{r}

eval_df <- eval_df[, !names(eval_df) %in% "INDEX"]
eval_df <- eval_df[, !names(eval_df) %in% "TEAM_BATTING_HBP"]
eval_df
```
### Mean/Median Imputation (For Numeric Data)

Instead of removing missing values, fill them with the mean or median:

```{r}

eval_df$TEAM_BATTING_SO[is.na(eval_df$TEAM_BATTING_SO)] <- mean(eval_df$TEAM_BATTING_SO, na.rm = TRUE)
eval_df$TEAM_BASERUN_SB[is.na(eval_df$TEAM_BASERUN_SB)] <- mean(eval_df$TEAM_BASERUN_SB, na.rm = TRUE)
eval_df$TEAM_BASERUN_CS[is.na(eval_df$TEAM_BASERUN_CS)] <- mean(eval_df$TEAM_BASERUN_CS, na.rm = TRUE)
eval_df$TEAM_FIELDING_DP[is.na(eval_df$TEAM_FIELDING_DP)] <- mean(eval_df$TEAM_FIELDING_DP, na.rm = TRUE)
eval_df$TEAM_PITCHING_SO[is.na(eval_df$TEAM_PITCHING_SO)] <- mean(eval_df$TEAM_PITCHING_SO, na.rm = TRUE)
```

#### 4. Verifying That Missing Values Are Fixed

```{r}

sum(is.na(eval_df))  # Total missing values
colSums(is.na(eval_df))  # Missing values per column

```

```{r}

skim(eval_df)
```

## Make Predictions Using the Improved_Model:

```{r}

# Generate predictions using the trained Improved Model
eval_df$PREDICTED_WINS <- predict(improved_model, newdata = eval_df)

# View a sample of predictions
head(eval_df$PREDICTED_WINS)

```
## Interpretation of Predicted TARGET_WINS Values

The predicted values represent the expected number of wins for teams based on their batting, pitching, and fielding statistics using the Improved Model.

For example:

A team with a predicted 69.15 wins is expected to win around 69 games in a full season.
A team with a predicted 82.52 wins is expected to perform better, likely finishing with around 82-83 wins.
The variation in predictions suggests that some teams are stronger than others based on key performance metrics (hits, home runs, walks, strikeouts, fielding errors, etc.).

### Evaluating the Accuracy of Predictions Against Actual TARGET_WINS

Now that we have predicted TARGET_WINS, we need to compare these predictions with the actual values in the TARGET_WINS column to assess model accuracy.

#### Step 1: Compute Error Metrics

```{r}
# Check structure of the dataset
str(eval_df)

# Check if ACTUAL_WINS and PREDICTED_WINS are numeric
is.numeric(eval_df$ACTUAL_WINS)
is.numeric(eval_df$PREDICTED_WINS)

```
#### Step 2: Add an INDEX Column to Each Dataset

```{r}
# Add a row index to both datasets
train_df$INDEX <- seq_len(nrow(train_df))  
eval_df$INDEX <- seq_len(nrow(eval_df))

```



#### Step 3: Align and Merge the Datasets

```{r}
# First, check if both datasets have a common identifier (like INDEX)
head(train_df$INDEX)
head(eval_df$INDEX)

# Merge train_df and eval_df using INDEX (if applicable)
merged_df <- merge(train_df[, c("INDEX", "TARGET_WINS")], 
                   eval_df[, c("INDEX", "PREDICTED_WINS")], 
                   by = "INDEX", all = FALSE)

# Now check if both columns have equal length
nrow(merged_df)  


```
Ensure data consistency before calculating accuracy metrics.
Convert to numeric to avoid errors in correlation or calculations.

#### Step 4: Compute Accuracy Metrics

```{r}


# Compute MAE, RMSE, and R²
mae <- mae(merged_df$TARGET_WINS, merged_df$PREDICTED_WINS)  
rmse <- rmse(merged_df$TARGET_WINS, merged_df$PREDICTED_WINS)  
r_squared <- cor(merged_df$TARGET_WINS, merged_df$PREDICTED_WINS)^2  

# Print results
cat("Model Accuracy Metrics:\n")
cat("Mean Absolute Error (MAE):", round(mae, 2), "\n")
cat("Root Mean Squared Error (RMSE):", round(rmse, 2), "\n")
cat("R-Squared (R²):", round(r_squared, 4), "\n")

```

### Interpretation of Model Accuracy Metrics

The evaluation results indicate that our Improved Model is not performing well in predicting TARGET_WINS.

The Mean Absolute Error (MAE) of 13.87 suggests that, on average, predictions deviate by about 14 wins per team, which is quite high. 

Additionally, the Root Mean Squared Error (RMSE) of 17.38 implies that some predictions have even larger errors, highlighting potential inconsistencies or missing key predictors. 

Most concerning is the R-Squared (R²) value of 0.001, which means that the model explains almost none of the variation in team wins—essentially, the predictions are no better than random guesses. 

This suggests that the model may be overfitting the training data and failing to generalize, or that it lacks critical predictive features. 

To improve performance, we should consider adding more relevant predictors (such as ERA or OBP), removing unimportant or noisy variables, and potentially using alternative mo


### Applying Prediction to Our Evalution

With our models tested and evaluated, we can no apply our model to our final evaluation dataframe.

```{r final-predictions}

predictedWins = predict(stp_logx_model, eval_df)
eval_df["PREDICTED_WINS"] = predictedWins

```